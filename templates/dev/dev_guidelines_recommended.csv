id,title,content
reco_1,"コンポーネント設計","- **単一責任の原則:** コンポーネントは一つの機能に集中させる。
- **再利用性:** 複数の場所で利用できる汎用的なコンポーネントの作成を心がける。"
reco_2,"パフォーマンス","- `useMemo`, `useCallback` を適切に使用し、不要な再レンダリングを避ける。
- `React.lazy` を用いたコンポーネントの遅延読み込みを検討する。"
reco_3,"ビルドとデプロイ","- ビルドコマンドは `npm run build` を使用します。
- `esbuild` により、フロントエンドのソースコードが `dist/bundle.js` にバンドルされます。
- `scripts/prepare-deployment.js` により、デプロイに必要なファイルが `dist/` ディレクトリにコピー・配置されます。

### PHPファイルの取り扱い
この開発環境の制約上、サーバーサイドのPHPファイルは直接 `.php` 拡張子で扱うことができません。

- **作業ファイル:** `api/` ディレクトリ内では、PHPのソースコードは必ず `.php.txt` という拡張子で作成・編集してください。
- **ビルド処理:** ビルドプロセス (`npm run build`) を実行すると、`scripts/prepare-deployment.js` がこれらの `.php.txt` ファイルを `dist/api/` ディレクトリにコピーする際、自動的に `.php` 拡張子にリネームします。
- **開発環境の制約:** このルールは、PHPファイルを直接編集するとエラーが発生する現在の開発環境の制約に対応するためのものです。詳細は「禁止事項」のセクションも参照してください。"
reco_4,"データソースの管理","このアプリケーションは、開発環境と本番環境でデータ取得方法を切り替える特殊な仕組みを採用しています。

- **データ取得ロジック:** アプリケーション全体のデータ取得ロジックは `data/db.ts` ファイルに集約されていますが、このファイルの内容はビルドプロセスによって動的に切り替えられます。

- **ソースファイル:**
    - `data/db.csv.api.ts.txt`: **開発環境用**のデータソース定義ファイルです。ローカルの `templates/*.csv` ファイルを読み込んでデータベースを構築するロジックが記述されています。
    - `data/db.php.api.ts.txt`: **本番環境用**のデータソース定義ファイルです。サーバー上の `/api/app-data.php` エンドポイントにリクエストを送り、データベースを取得するロジックが記述されています。

- **切り替えプロセス:**
    1. **開発時:** 開発環境では、`data/db.csv.api.ts.txt` の内容を `data/db.ts` として使用します。これにより、ローカルのCSVデータを参照して開発を進めることができます。
    2. **ビルド時:** `npm run build` を実行すると、`build:prepare` スクリプトが `data/db.php.api.ts.txt` の内容を `data/db.ts` に上書きコピーします。これにより、ビルドされたアプリケーションは本番用のPHP APIを参照するようになります。
    3. **ビルド後:** ビルドプロセス完了後、`build:cleanup` スクリプトによって `data/db.ts` の内容は再び開発用の `data/db.csv.api.ts.txt` の内容に戻されます。これにより、ビルド後も開発環境はローカルCSVを参照する状態が維持されます。"
reco_5,"アーキテクチャパターン (暗黙知の明文化)","このプロジェクトでは、推奨仕様に明記されていないものの、開発の過程で形成されたいくつかの重要な設計パターン（型）が存在します。これらを遵守することで、コードの一貫性とメンテナンス性が向上します。

### 状態管理
- **イミュータブルな更新:** `database` のような巨大な状態を `useState` で更新する際は、必ず関数形式 (`setDatabase(prev => { ... })`) を使用してください。これにより、更新前の最新の状態を確実に参照でき、競合を防ぎます。
- **データ変換層:** `database` から取得した生データは、コンポーネントで直接使わず、`useMemo` を使ってUIが必要とする形式に加工してから渡してください。これにより、コンポーネントは表示ロジックに集中でき、パフォーマンスも向上します。

### コンポーネント設計
- **Controlled Modal:** モーダルコンポーネントは、親コンポーネントが `isOpen` 状態を管理し、モーダル内での結果はコールバック (`onSelect` など) で親に通知する「Controlled Component」として設計してください。モーダル自身が表示・非表示のロジックを持たないようにします。
- **ロジックとビューの分離:** 状態管理や複雑なロジックを持つコンポーネント（例: `Estimator.tsx`）と、データを受け取って表示に特化するコンポーネント（例: `CostSummary.tsx`）を明確に分離してください。

### API・サービス連携
- **サービスの集約:** 外部APIとの通信（例: `geminiService.ts`）や、複雑なビジネスロジック（例: `costService.ts`）は、すべて `services/` ディレクトリ内のファイルに集約してください。コンポーネントが直接APIを叩いたり、複雑な計算を行ったりしないようにします。
- **動的スキーマ生成:** AIにJSON形式の出力を求める際は、`geminiService.ts` にあるような動的なレスポンススキーマ生成関数を活用し、出力形式を厳密に制御してください。"
reco_6,"データテーブルの分離","アプリケーションの保守性と拡張性を高めるため、データは適切に分離して管理します。

- **機能ごとのテーブル作成:**
新しいツールや設定機能を追加する際は、`settings` のような汎用テーブルを拡張するのではなく、その機能専用の新しいデータテーブルを作成してください。（例: `pdf_template_settings`, `email_accounts`）。これにより、データの独立性が保たれ、将来のメンテナンスが容易になります。

- **コンテンツごとのテーブル作成:**
UI上でタブなどで切り替えて表示する類似したコンテンツ群（例: 開発憲法の各条項、ロードマップの各項目）は、単一のテーブルで `type` フィールドを使って区別するのではなく、それぞれ独立したテーブルとして設計してください。（例: `dev_constitution`, `dev_roadmap`）。これにより、各コンテンツ固有のデータ構造に柔軟に対応できます。"
reco_7,"データ取得の基本方針: オンデマンド読み込み (Just-in-Time Data Fetching)","アプリケーションのパフォーマンスとスケーラビリティを確保するため、データ取得は以下の「オンデマンド読み込み」を原則とします。

### 原則
アプリケーション起動時にすべてのデータを一括で読み込むのではなく、各ツールやコンポーネントが表示されるタイミングで、**その機能に必要な最小限のデータのみ**をAPIから取得します。

### なぜ重要か？
- **初期ロード時間の短縮:** ユーザーがアプリケーションを使い始めるまでの待ち時間を大幅に削減します。
- **メモリ効率:** ブラウザが必要としない大量のデータをメモリ上に保持することを防ぎます。
- **スケーラビリティ:** 将来データ量が増加しても（例: 顧客が1万人を超える）、パフォーマンスへの影響を最小限に抑えられます。

### 実装ガイドライン
- **データ取得の責務:** 各ツールコンポーネントが、自身の機能に必要なデータを取得する責任を持ちます。
- **取得のタイミング:** `useEffect`フックなどを利用し、コンポーネントがマウント（表示）されたタイミングでデータ取得処理を実行します。
- **取得用関数:** データ取得には、`data/db.live.ts` にある `fetchTables` 関数を利用します。この関数は、現在のアプリケーションモード（`live`, `csv-debug`, `mock`）を自動的に判別し、適切なデータソースからデータを取得します。
- **ロード中のUI:** データ取得中は、必ずローディングスピナーなどを表示し、ユーザーに処理中であることを明確に伝えてください。

### 禁止事項
アプリケーションのルートコンポーネント（例: `App.tsx`）で、多くのツールが利用する可能性のあるデータを事前に一括で読み込む実装は、原則として禁止します。（ログインユーザー情報など、真にグローバルで常に必要なデータは除く）"
reco_8,"コンポーネントのエクスポート（default vs 名前付き）","コンポーネントのエクスポート方法には `export default` と `export { ComponentName }` (名前付きエクスポート) の2種類があり、一貫したルールで使い分けることが重要です。特に `React.lazy()` での動的インポート時に問題が発生しやすいため、以下のルールを推奨します。

### 原則
- **ページコンポーネントや単一機能の主要コンポーネント:** `export default` を使用します。
- **再利用可能なUI部品や、一つのファイルに複数の小さなコンポーネントが含まれる場合:** 名前付きエクスポート `export { ... }` を使用します。

### `React.lazy()` での動的インポート
`React.lazy()` は **`export default` されたコンポーネント**を期待します。

**良い例 (`MyPage.tsx`):**
```tsx
const MyPage = () => { /* ... */ };
export default MyPage;
```
**インポート側 (`App.tsx`):**
```tsx
const MyPage = lazy(() => import('./pages/MyPage'));
```

もし名前付きエクスポートされたコンポーネントを `lazy()` で読み込む必要がある場合は、以下のように記述する必要があります。

**悪い例を修正 (`icons.tsx`):**
```tsx
export const PencilIcon = () => { /* ... */ };
export const TrashIcon = () => { /* ... */ };
```
**インポート側 (`App.tsx`):**
```tsx
const PencilIcon = lazy(() => 
  import('./components/icons').then(module => ({ default: module.PencilIcon }))
);
```
この方法は複雑になるため、原則として `lazy()` で読み込む対象は `export default` してください。

### 使い分けの例

- **`App.tsx`:** アプリケーションのルートなので `export default App;`
- **`components/OrderManagementTool.tsx`:** ツール全体を表す主要なコンポーネントなので `export default OrderManagementTool;`
- **`components/icons.tsx`:** 複数のアイコンコンポーネントを一つのファイルにまとめているので、それぞれ名前付きエクスポートします。
  ```tsx
  export const PencilIcon = ...;
  export const TrashIcon = ...;
  ```
- **`types.ts`:** 複数の型定義をエクスポートするため、すべて名前付きエクスポートします。
  ```tsx
  export interface Row { ... };
  export interface Database { ... };
  ```

このルールを徹底することで、動的インポート時の `Element type is invalid...` といったエラーを防ぎ、コードの可読性を向上させます。"
reco_9,"設計原則: Atomic Designの採用","### 設計原則: Atomic Designの採用

プロジェクトの規模に関わらず、UIコンポーネントの設計には **Atomic Design** を全面的に採用することを強く推奨します。これは、UIを再利用可能な小さな部品（`Atoms`→`Molecules`→`Organisms`）から組み立てていく設計手法です。

#### なぜAtomic Designを採用するのか？

1.  **将来の拡張性と保守性の確保**
    -   最初は小さくても、機能追加を重ねるうちにコンポーネントは肥大化・複雑化し、いずれ分割の必要性に迫られます。
    -   最初から再利用可能な部品として設計することで、この問題を未然に防ぎ、長期的なメンテナンスコストを大幅に削減できます。

2.  **Google AI Studioとの圧倒的な親和性**
    -   この開発環境の最大の特徴は、**AIが私たちの指示を忠実に実行してくれる**点にあります。
    -   あらかじめ基本的なUI部品（`Atoms`や`Molecules`）を用意しておくことで、AIはそれらを**「レゴブロック」のように**組み合わせてUIを構築してくれます。
    -   これにより、「ボタンを追加して」という指示だけで一貫したデザインが適用され、カスタムが必要な部分のみに集中して指示を出せるため、開発効率が飛躍的に向上します。

3.  **開発の安全性と品質の向上**
    -   AIが大規模なファイルを編集すると、意図しない変更やバグが発生するリスクが高まります。
    -   コンポーネントが小さく分割されていれば、AIの編集範囲も限定され、変更の影響を予測しやすくなるため、バグのリスクを大幅に低減できます。
    -   結果として、プロジェクトの規模に関わらず、開発の安全性、効率性、そして最終的なツールの品質を同時に高めることができます。

#### 目指すゴール
Atomic Designは、Google AI Studioを単なる「アイデアのたたき台を作るツール」から、**「コードを全く知らない人でも、仕事で使える本格的で高品質なツールを構築・メンテナンスできるプラットフォーム」**へと昇華させるための、最も重要な設計基盤です。"
reco_10,"機能設計: 関数型プログラミングの採用","UI設計でAtomic Designを採用するのと同様に、機能やロジックの設計には**関数型プログラミング (Functional Programming) の考え方**を強く推奨します。これは、UIとロジックの両面で同じ「合成（Composition）」のアプローチを取るものです。

- **UI (見た目) → Atomic Design:** 小さなUI部品（Atoms）を組み合わせて大きなコンポーネントを作ります。
- **ロジック (機能) → 関数型プログラミング:** 小さく独立した**純粋関数 (Pure Function)** を組み合わせて、大きな機能を作ります。

#### なぜ推奨するのか？

1.  **AIとの親和性:**
    AIは「送料を計算する」「税金を計算する」といった小さく単純な純粋関数を理解し、それらをレゴブロックのように組み合わせて新しい複雑な計算ロジックを正確に構築してくれます。これにより、AIによるコード生成・編集の精度と安全性が飛躍的に向上します。

2.  **テスト容易性と品質向上:**
    各関数が独立しているため、単体テストが非常に容易になり、バグの特定と修正が迅速に行えます。

3.  **予測可能性と保守性:**
    副作用（関数の外の状態を変更すること）がない純粋関数は、動作が予測しやすく、将来の仕様変更時にも影響範囲を限定できます。

#### 良い例
`services/costService.ts` の `calculateCost` 関数は、まさにこの考え方を体現しています。大きなコスト計算機能が、`calculateTshirtAndUnitPrice` や `calculateShippingCost` といった、より小さく単純な関数の組み合わせで構築されています。

#### 結論
今後の開発では、**UIはAtomic Design**、**機能は関数型プログラミング**を両輪とし、アプリケーション全体の品質、保守性、そしてAIとの協調開発効率を最大化します。"
reco_11,"キャッシュ問題の恒久対策（キャッシュバスティング）","### 問題
ブラウザは一度読み込んだJavaScriptファイル (`index.js`) を高速化のために記憶（キャッシュ）します。これにより、コードを修正しても、ブラウザが古いキャッシュを使い続けてしまい、**「修正が反映されない」という致命的な問題**が頻発します。

### 対策（必須事項）
この問題を恒久的に回避するため、`index.html`でJavaScriptファイルを読み込む際に、**必ず**バージョン情報（タイムスタンプなど）をクエリパラメータとして付与します。

**実装例 (`index.html`):**
```html
<script type=""module"" src=""/index.js?v=${new Date().getTime()}""></script>
```

### なぜ効果的か？
`<script>` タグの `src` 属性の値が毎回 `index.js?v=1722498600000` のように変化するため、ブラウザは「新しいファイルだ」と認識し、キャッシュを使わずに必ず最新のファイルをサーバーから取得するようになります。

これにより、開発中の修正が即座に反映され、開発効率と信頼性が大幅に向上します。"
reco_12,"キャッシュ対策の仕組み（詳細）","### なぜ全ての.tsxファイルの変更が反映されるのか？

このアプリケーションは **`esbuild`** という**バンドラ（bundler）** を使用しています。バンドラは、複数のJavaScript/TypeScriptファイルを解析し、それらを**一つにまとめる**ツールです。

**プロセス:**
1.  ビルドが実行されると、`esbuild` はエントリーポイントである `index.tsx` を読み込みます。
2.  `index.tsx` 内の `import` 文をたどり、`App.tsx`, `Sidebar.tsx`, `Login.tsx` など、アプリケーションで使われている**すべての `.tsx` ファイル**をかき集めます。
3.  集めたすべてのコードを一つにまとめ、`dist/index.js` という単一のJavaScriptファイルを生成します。

**結論:**
この仕組みにより、あなたが **どの `.tsx` ファイルを編集しても**、最終的に生成される `dist/index.js` の内容は変わります。
そして `index.html` は、`?v=...` のおかげで常に最新の `index.js` を読み込むように設定されています。
したがって、アプリケーションのロジックに関する限り、あなたの変更は常にブラウザに反映されます。

### `index.css` について
`index.css` はこのバンドルの仕組みの外にあるため、キャッシュされる可能性があります。しかし、このファイルはごく基本的なスタイルのみを定義しており、頻繁に変更されることはありません。もし変更を加えて反映されない場合は、ブラウザのキャッシュを手動でクリアしてください。"
reco_13,"変更内容の伝達と確認方法","「修正したのに何が変わったかわからない」という問題を解消し、開発の透明性を高めるため、AIアシスタントはコード変更時に必ず以下の3つの情報を提供します。

### 1. 変更の概要（やったこと）
- どのような修正・変更を行ったのかを簡潔に説明します。

### 2. 変更点の詳細（どう変わったか）
- **見た目の変化:** UIの視覚的な変更点を具体的に記述します。**もし見た目に変化がない場合は、その旨を明確に伝えます。**
- **動作の変化:** これまでと挙動が変わる部分、エラーが解消された操作などを具体的に記述します。

### 3. 確認方法
- ユーザーがその変更を**実際に自分の手で確認できる、簡単な手順**を提示します。これにより、ユーザーはコードを読まなくても変更が正しく適用されたことを検証できます。

このルールを徹底することで、コミュニケーションの齟齬をなくし、ユーザーが安心して開発の進行を確認できる環境を目指します。"
reco_14,"CSSビルド戦略: Tailwind CSS ハイブリッドアプローチ","このアプリケーションでは、開発体験と本番環境のパフォーマンスを両立させるため、Tailwind CSSの「ハイブリッドアプローチ」を採用しています。

### 開発時 (ライブプレビュー)
- **CDNを利用:** `index.html`にCDNスクリプトを直接読み込みます。
- **メリット:** ファイル保存時のリアルタイムプレビューが高速に動作し、ビルドプロセスが不要なため、開発体験が向上します。

### 本番用ビルド時 (`npm run build`)
- **静的CSSファイルを生成:** `tailwindcss` CLIを使用して、プロジェクト内の全ファイルから使用されているクラスを抽出し、最適化・圧縮された単一のCSSファイル (`dist/index.css`) を生成します。
- **スクリプトの自動削除:** ビルドプロセスの一部として `scripts/prepare-deployment.js` が実行され、`dist/index.html` からCDN関連の `<script>` タグを自動的に削除します。
- **メリット:** 最終的な成果物はCDNに依存せず、必要なスタイルのみを含むため、ファイルサイズが小さく、ページの読み込み速度が向上します。

### 関連ファイル
- **`package.json`:** `devDependencies` に `tailwindcss`, `postcss`, `autoprefixer` が含まれ、`scripts` に `build:css` コマンドが定義されています。
- **`tailwind.config.js`:** Tailwind CSSのすべての設定（テーマ、プラグイン、スキャン対象ファイルなど）が定義されています。
- **`postcss.config.js`:** Tailwind CSSを通常のCSSに変換するための設定ファイルです。
- **`index.css`:** `@tailwind` ディレクティブと、アプリケーション固有のカスタムCSSが記述されています。
- **`scripts/prepare-deployment.js`:** 本番ビルド時に `index.html` を加工するスクリプトです。"
