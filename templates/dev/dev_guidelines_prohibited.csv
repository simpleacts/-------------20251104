id,title,content
proh_1,"パスのエイリアスと相対パスの記述方法について","この開発環境では、webpackなどのバンドラーによるパスエイリアス解決機能（例: `@/components/...`）がサポートされていません。**すべてのファイル参照は、現在のファイルからの相対パスで記述する必要があります。**

---

### 【パターンA】同じ階層のファイルを読み込む場合（例: `index.tsx` から `App.tsx`）
**これは最もよくある間違いのパターンです。**
```
/
├── index.tsx  (← 現在地)
└── App.tsx    (← 読み込みたいファイル)
```
`index.tsx` と `App.tsx` は同じ階層にあります。この場合、`./` を使って「**このフォルダにある**」ことを示します。

- **悪い例:** `import App from './components/App';` ( `components` フォルダは存在しません)
- **良い例:** `import App from './App';`

---

### 【パターンB】下の階層（サブフォルダ）のファイルを読み込む場合（例: `App.tsx` から `components/Sidebar.tsx`）
```
/
├── App.tsx      (← 現在地)
└── components/
    └── Sidebar.tsx (← 読み込みたいファイル)
```
`./` で現在のフォルダから始め、`components/` でサブフォルダに入り、目的のファイルを指定します。

- **良い例:** `import Sidebar from './components/Sidebar';`

---

### 【パターンC】上の階層のファイルを読み込む場合（例: `components/Sidebar.tsx` から `types.ts`）
```
/
├── types.ts      (← 読み込みたいファイル)
└── components/
    └── Sidebar.tsx (← 現在地)
```
`../` を使って「**一つ上のフォルダに移動**」してから、目的のファイルを指定します。

- **良い例:** `import type { Row } from '../types';`

---

### まとめ
- `./` : **このフォルダから**始める
- `../` : **一つ上のフォルダへ**移動する"
proh_2,"PHPファイルの取り扱いについて","この開発環境の制約上、PHPファイル (`.php`) を直接生成・更新するとエラーが発生します。

そのため、サーバーサイドのロジックを含むPHPファイルを扱う場合は、必ずファイル名の末尾に `.txt` を付けた拡張子 (`.php.txt`) で作業してください。

**悪い例:**
`<file>api/my_script.php</file>`

**良い例:**
`<file>api/my_script.php.txt</file>`

ビルドプロセスにおいて、`.php.txt` ファイルは自動的に `.php` ファイルにリネームされ、サーバーにデプロイされます。この処理は `scripts/prepare-deployment.js` に記述されています。"
proh_3,"アーキテクチャ上の制約","現在の開発環境とシンプルな構成を維持するため、以下の事項は禁止されています。

### サーバーサイドでの複雑なロジック
- **禁止:** サーバーサイド（PHP）で原価計算や複雑なデータ加工などのビジネスロジックを実装しないでください。
- **理由:** 現在のバックエンドは単純なデータのCRUD（作成・読み取り・更新・削除）に特化しており、複雑な処理を実行する能力を持ちません。すべてのビジネスロジックはフロントエンド（ブラウザ上）で実行する必要があります。

### 高度な状態管理ライブラリ
- **禁止:** Redux, Zustand, Recoilなどのサードパーティ製状態管理ライブラリを導入しないでください。
- **理由:** アプリケーションの複雑性を低く保つため、状態管理は `useState` と React Context（必要最小限）に限定します。プロップスのバケツリレーがある程度発生することは許容します。

### リアルタイム同期
- **禁止:** WebSocketなどを用いたリアルタイムでのデータ同期機能を実装しないでください。
- **理由:** バックエンドがリアルタイム通信をサポートしていません。データはユーザー操作のたびに読み込み・更新する方式を維持します。"
proh_4,"外部機能の統合について","**禁止:** 外部で開発された機能（例: 別のウェブアプリ）を、検証プロセスなしに直接本アプリケーションにマージしないでください。過去にこの手順を怠った結果、アプリケーション全体が完全に動作しなくなる重大な障害が発生しました。

**手順:**
1.  **デッドコードとしての取り込み:** 外部機能のソースコードは、まず本アプリケーション内で一切呼び出されない「デッドコード」として追加してください。どのファイルからも `import` されず、ルーティングも設定されていない状態にします。
2.  **検証環境でのビルド:** 上記の状態で、検証可能な環境（ローカル開発環境やステージング環境など）でアプリケーションが正常にビルドでき、既存機能が問題なく動作することを**必ず**確認してください。
3.  **段階的な統合:** ビルドと動作確認が完了した後、初めて機能を少しずつ有効化（`import` の追加、ルーティングの設定など）していくことが許可されます。

**理由:** このプロセスにより、外部コードが既存のファイル構造、型定義、依存関係と衝突してビルドエラーや実行時エラーを引き起こす問題を、本番環境に影響を与える前に検知することができます。"
proh_5,"更新・修正の適用方法について","**禁止:** アプリケーションに複数の変更を一度に適用しないでください。

**手順:**
1.  **変更は一つずつ:** 機能追加、バグ修正、リファクタリングなど、変更は必ず一つずつ段階的に行ってください。"
proh_6,"ユーザーの意図しない実装の禁止","ユーザーの意図を正確に反映し、誤った変更を防ぐため、以下のルールを厳格に遵守してください。

### 1. 質問と実装依頼の明確な区別
- ユーザーからのプロンプトが**質問形式**（例: 「～について教えてください」「～は可能ですか？」）である場合、コードの変更は**一切行わず**、質問に対する回答のみを生成してください。
- 「～してください」「～を変更してください」「～を追加して」といった**明確な実装指示**があった場合にのみ、コードの変更を行ってください。勝手な判断で実装を開始することは固く禁止します。

### 2. 最終プロンプトの絶対遵守
- 実装に取り掛かる前に、必ず**ユーザーから最後に送信されたプロンプトの内容を再確認**してください。
- 以前の会話の流れや文脈に引きずられてはいけません。常に**最新の指示が絶対的な正**であると解釈してください。以前の指示と矛盾する場合でも、最新の指示を優先して実装を行ってください。"