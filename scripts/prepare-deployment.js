const fs = require('fs');
const path = require('path');

const distDir = 'dist';

// Helper function for recursive directory copy to ensure Node.js version compatibility.
const copyDirRecursiveSync = (src, dest) => {
    const exists = fs.existsSync(src);
    if (!exists) {
        // This is not an error, it could be an optional directory like PHPMailer.
        // Let the calling context decide if it's a warning.
        return;
    }
    const stats = fs.statSync(src);
    const isDirectory = stats.isDirectory();
    if (isDirectory) {
        if (!fs.existsSync(dest)) {
           fs.mkdirSync(dest, { recursive: true });
        }
        fs.readdirSync(src).forEach(childItemName => {
            copyDirRecursiveSync(path.join(src, childItemName), path.join(dest, childItemName));
        });
    } else {
        fs.copyFileSync(src, dest);
    }
};

// 1. Process index.html and other root assets first
try {
    console.log('--- Starting post-build asset preparation ---');
    
    // Process and copy index.html to dist from root, embedding a timestamp for cache busting.
    const timestamp = new Date().getTime();
    let indexHtmlContent = fs.readFileSync('index.html', 'utf-8');
    indexHtmlContent = indexHtmlContent.replace('?v=__BUILD_TIMESTAMP__', `?v=${timestamp}`);
    
    // Remove Tailwind CDN and inline config for production build
    indexHtmlContent = indexHtmlContent.replace(/<script src="https:\/\/cdn\.tailwindcss\.com\?plugins=typography"><\/script>\s*/, '');
    indexHtmlContent = indexHtmlContent.replace(/<script>\s*tailwind\.config\s*=\s*{[\s\S]*?}\s*<\/script>\s*/, '');
    
    // Remove development script tag for index.tsx (production uses index.js instead)
    indexHtmlContent = indexHtmlContent.replace(/<script type="module" src="\/index\.tsx"><\/script>\s*/g, '');

    const indexHtmlPath = path.join(distDir, 'index.html');
    if (fs.existsSync(indexHtmlPath)) {
        fs.unlinkSync(indexHtmlPath);
    }
    fs.writeFileSync(indexHtmlPath, indexHtmlContent);
    const now = new Date();
    fs.utimesSync(indexHtmlPath, now, now);
    console.log('Processed index.html for production.');

    // Copy other static assets from root
    const metadataDest = path.join(distDir, 'metadata.json');
    if (fs.existsSync(metadataDest)) {
        fs.unlinkSync(metadataDest);
    }
    fs.copyFileSync('metadata.json', metadataDest);
    fs.utimesSync(metadataDest, now, now);
    console.log('Copied metadata.json.');
    
    // Copy composer.json for server-side installation
    if (fs.existsSync('composer.json')) {
        const composerDest = path.join(distDir, 'composer.json');
        if (fs.existsSync(composerDest)) {
            fs.unlinkSync(composerDest);
        }
        fs.copyFileSync('composer.json', composerDest);
        fs.utimesSync(composerDest, now, now);
        console.log('Copied composer.json.');
    }
    
    // index.css is now generated by the build:css script, so we don't copy it from the root anymore.

    // Use a compatible recursive copy for the 'templates' directory
    copyDirRecursiveSync('templates', path.join(distDir, 'templates'));
    console.log('Copied templates directory.');
    
    // Remove duplicate database_setup.sql.txt from dist/templates (it's already in dist root)
    const duplicateDbSetup = path.join(distDir, 'templates', 'database_setup.sql.txt');
    if (fs.existsSync(duplicateDbSetup)) {
        fs.unlinkSync(duplicateDbSetup);
        console.log('Removed duplicate database_setup.sql.txt from dist/templates.');
    }
    
    // Copy data directory for mock data
    copyDirRecursiveSync('data', path.join(distDir, 'data'));
    console.log('Copied data directory.');
    
    // Copy database_setup.sql.txt if it exists (it may be in templates/ or root)
    const databaseSetupSqlPath = fs.existsSync('database_setup.sql.txt') 
        ? 'database_setup.sql.txt' 
        : path.join('templates', 'database_setup.sql.txt');
    
    if (fs.existsSync(databaseSetupSqlPath)) {
        const dbSetupDest = path.join(distDir, 'database_setup.sql.txt');
        if (fs.existsSync(dbSetupDest)) {
            fs.unlinkSync(dbSetupDest);
        }
        fs.copyFileSync(databaseSetupSqlPath, dbSetupDest);
        const now = new Date();
        fs.utimesSync(dbSetupDest, now, now);
        console.log('Copied database_setup.sql.txt.');
    } else {
        console.warn('Warning: database_setup.sql.txt not found, skipping.');
    }

    // Copy vendor directory (mPDF and other Composer dependencies)
    const vendorSource = 'vendor';
    if (fs.existsSync(vendorSource)) {
        copyDirRecursiveSync(vendorSource, path.join(distDir, 'vendor'));
        console.log(`Copied directory: ${vendorSource} -> ${path.join(distDir, 'vendor')}`);
    } else {
        console.warn(`Warning: vendor directory not found, skipping: ${vendorSource}`);
        console.warn('Note: Run "composer install" to install mPDF and other dependencies.');
    }

    // Copy or create cache directory (mPDF temporary files)
    const cacheSource = 'cache';
    const cacheDest = path.join(distDir, 'cache');
    if (fs.existsSync(cacheSource)) {
        copyDirRecursiveSync(cacheSource, cacheDest);
        console.log(`Copied directory: ${cacheSource} -> ${cacheDest}`);
    } else {
        // Create empty cache directory if it doesn't exist
        if (!fs.existsSync(cacheDest)) {
            fs.mkdirSync(cacheDest, { recursive: true });
            console.log(`Created directory: ${cacheDest}`);
        }
    }


} catch (error) {
    console.error('Error preparing base assets:', error);
    process.exit(1);
}

// 2. Process API files with the new logic
const apiSourceDir = 'api';
const distApiDir = 'dist/api';
const backupApiDir = 'backup/api';  // distの外に配置

try {
    console.log('Preparing API files...');
    
    // Ensure dist/api exists
    if (!fs.existsSync(distApiDir)) {
        fs.mkdirSync(distApiDir, { recursive: true });
        console.log(`Created directory: ${distApiDir}`);
    }

    // Ensure backup directory exists (distの外)
    if (!fs.existsSync(backupApiDir)) {
        fs.mkdirSync(backupApiDir, { recursive: true });
        console.log(`Created backup directory: ${backupApiDir}`);
    }

    // 自動的にapiフォルダ内のすべての.phpファイルを検出
    if (!fs.existsSync(apiSourceDir)) {
        console.warn(`Warning: API directory not found: ${apiSourceDir}`);
    } else {
        const files = fs.readdirSync(apiSourceDir, { withFileTypes: true });
        const phpFiles = files
            .filter(item => item.isFile() && item.name.endsWith('.php') && !item.name.endsWith('.php.txt'))
            .map(item => item.name);

        console.log(`Found ${phpFiles.length} PHP files in ${apiSourceDir}`);

        // Process PHP files: copy to dist/api and create backup as .php.txt
        phpFiles.forEach(file => {
            const sourcePath = path.join(apiSourceDir, file);
            const distPath = path.join(distApiDir, file);
            const backupPath = path.join(backupApiDir, file + '.txt');

            if (fs.existsSync(sourcePath)) {
                // Read source file and remove BOM if present
                let content = fs.readFileSync(sourcePath);
                // Remove UTF-8 BOM (0xEF 0xBB 0xBF)
                if (content.length >= 3 && content[0] === 0xEF && content[1] === 0xBB && content[2] === 0xBF) {
                    content = content.slice(3);
                    console.log(`Removed BOM from: ${sourcePath}`);
                }
                
                // Copy to dist/api for build (without BOM)
                if (fs.existsSync(distPath)) {
                    fs.unlinkSync(distPath);
                }
                fs.writeFileSync(distPath, content);
                const now = new Date();
                fs.utimesSync(distPath, now, now);
                console.log(`Copied to dist: ${sourcePath} -> ${distPath}`);

                // Create backup as .php.txt (distの外, without BOM)
                if (fs.existsSync(backupPath)) {
                    fs.unlinkSync(backupPath);
                }
                fs.writeFileSync(backupPath, content);
                fs.utimesSync(backupPath, now, now);
                console.log(`Created backup: ${sourcePath} -> ${backupPath}`);
            } else {
                console.warn(`Warning: Source file not found, skipping: ${sourcePath}`);
            }
        });
    }

    // Copy PHPMailer directory using the compatible recursive copy
    const phpMailerSource = path.join(apiSourceDir, 'PHPMailer');
    if (fs.existsSync(phpMailerSource)) {
        copyDirRecursiveSync(phpMailerSource, path.join(distApiDir, 'PHPMailer'));
        console.log(`Copied directory: ${phpMailerSource} -> ${path.join(distApiDir, 'PHPMailer')}`);
    } else {
         console.warn(`Warning: PHPMailer directory not found, skipping: ${phpMailerSource}`);
    }

    // Copy .htaccess from htaccess.txt
    const htaccessSource = 'htaccess.txt';
    const htaccessDest = path.join(distDir, '.htaccess');
    if (fs.existsSync(htaccessSource)) {
        if (fs.existsSync(htaccessDest)) {
            fs.unlinkSync(htaccessDest);
        }
        fs.copyFileSync(htaccessSource, htaccessDest);
        const now = new Date();
        fs.utimesSync(htaccessDest, now, now);
        console.log(`Copied: ${htaccessSource} -> ${htaccessDest}`);
    } else {
        console.warn(`Warning: htaccess.txt not found, skipping.`);
    }

    console.log('API files prepared successfully.');
    console.log('--- Post-build asset preparation complete ---');
    process.exit(0);
} catch (error) {
    console.error('Error preparing API files:', error);
    process.exit(1);
}